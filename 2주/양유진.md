## 🗂 ch07. 연산자

**연산자(operator)**는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 **하나의 값을 만드는** 예약된 구문이다. 연산의 대상은 **피연산자(operand)**라고 하며, 피연산자는 **값**으로 평가될 수 있는 표현식이어야 한다.

### 7-1. 산술 연산자

**산술 연산자**는 피연산자를 대상으로 **수학적 계산**을 수행해 **새로운 숫자 값**을 만드는데, 산술 연산이 불가능한 경우 NaN을 반환한다.

#### 이항 산술 연산자

이항(binary) 산술 연산자는 2개의 피연산자를 산술하여 숫자 값을 만든다. 우리가 간단한 사칙 연산을 할 때의 식을 생각해도 된다.

```
5 + 2;   // → 7   (덧셈)
5 - 2;   // → 3   (뺄셈)
5 * 2;   // → 10   (곱셈)
5 / 2;   // → 2.5   (나눗셈)
5 % 2;   // → 1   (나머지)
```

#### 단항 산술 연산자

단항(unary) 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.

| 단항 산술 연산자 | 의미                                               | 부수 효과 |
| :--------------- | :------------------------------------------------- | :-------- |
| ++               | 증가                                               | O         |
| \--              | 감소                                               | O         |
| +                | 어떠한 효과도 없다.                                | X         |
| \-               | 양수를 음수로, 음수를 양수로 반전한 값을 반환한다. | X         |

이항 산술 연산자와 달리 증가/감소(++/--) 단항 산술 연산자는 피연산자의 값을 변경하는 **부수 효과(암묵적 할당)**가 있다. 증가/감소(++/--) 연산자는 위치에 따라 수행 결과가 달라진다.

- 피연산자 '앞'에 위치  
  먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.
- 피연산자 '뒤'에 위치  
  먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.

```
// 증가/감소(++/--) 연산자 위치 예시
var x = 5, result;

// 선 할당, 후 증가
result = x++;
console.log(result, x);   // 5 6

// 선 증가, 후 할당
result = ++x;
console.log(result, x);   // 7 7

// 선 할당, 후 감소
result = x--;
console.log(result, x);   // 7 6

// 선 감소, 후 할당
result = --x;
console.log(result, x);   // 5 5
```

아래 예시 코드는 간단한 내용이지만, 헷갈리기 쉬운 내용인 것 같아 참고용으로 남겨보는 코드이다. 표현식의 평가 시점을 생각하면 도움이 될 것 같다.

```
// 예시1
for(let i=0; i<10; i++) {
    console.log(i);
}

// 예시2
for(let i=0; i<10; ++i) {
    console.log(i);
}

// 예시1, 예시2의 출력 결과는 동일하다.
// 결과) 0부터 9까지 console.log 출력


// 예시3
for(let i=0; i<10) {
    console.log(++i);
}
// 결과) 1부터 10까지 console.log 출력
```

#### 문자열 연결 연산자

'+' 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작한다. 이때 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 **암묵적 타입 변환(또는 타입 강제 변환)**이 일어나기도 하므로 이 부분까지 고려하여 작성해야한다.

```
// 문자열 연결 연산자
'1' + 2;   // → '12'
1 + '2';   // → '12'

// 암묵적 타입 변환
1 + true;   // → 2
1 + false;   // → 1
1 + null;   // → 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined;   // → NaN
1 + undefined;   // → NaN
```

### 7-2. 할당 연산자

\*\_할당 연산자(assignment operator)\\\_\*는 우항에 있는 \*\*피연산자의 평가 결과\*\*를 좌항에 있는 \*\*변수에 할당\*\*한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있다.

| 할당 연산자 | 예      | 동일 표현  | 부수 효과 |
| :---------- | :------ | :--------- | :-------- |
| \=          | x = 5   | x = 5      | O         |
| +=          | x += 5  | x = x + 5  | O         |
| \-=         | x -= 5  | x = x - 5  | O         |
| \*=         | x \*= 5 | x = x \* 5 | O         |
| /=          | x /= 5  | x = x / 5  | O         |
| %=          | x %= 5  | x = x % 5  | O         |

또한, **할당문은** 값으로 평가되는 **표현식**인 문으로서 할당된 값으로 평가된다. 이런 특징을 활용해 동일한 값을 여러 변수에 연쇄 할당할 수 있다.

`var a = b = c = 0;`

### 7-3. 비교 연산자

**비교 연산자(comparison operator)**는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 **불리언 값으로 반환**한다. 이 연산자는 if문이나 for문 같은 제어문의 조건식에서 주로 사용된다.

#### 동등/일치 비교 연산자

동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교하는데, 일치 비교 연산자가 '값'과 함께 '데이터 타입'까지 비교하여 보다 엄격한 비교를 한다.

| 비교 연산자 | 의미        | 사례    | 설명                         |
| :---------- | :---------- | :------ | :--------------------------- |
| \==         | 동등 비교   | x == y  | x와 y의 값이 같음            |
| \===        | 일치 비교   | x === y | x와 y의 '값'과 '타입'이 같음 |
| !=          | 동등 비교   | x != y  | x와 y의 값이 다름            |
| !==         | 불일치 비교 | x !== y | x와 y의 '값'과 '타입'이 다름 |

동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때, 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다. 이러한 점은 편리하기도 하지만, 의도와 다른 결과를 낳을 수도 있어 예측하기 어려우므로 암묵적 타입 변환 없이 엄격한 비교를 하는 **일치 비교(===) 연산자를 사용하는 것이 권장**된다.

**✋ 주의**  
일치 비교 연산자에서 **NaN은 자신과 일치하지 않는 유일한 값**으로, 숫자가 NaN인지 비교하려면 **Number.isNaN 빌트인 함수**를 사용한다.

```
console.log(isNaN(NaN));   // → true
console.log(isNaN(-NaN));   // → true
console.log(isNaN(undefined));   // → true
console.log(isNaN(null));   // → false
console.log(isNaN({}));   // → true
console.log(isNaN(+'12345'));   // →false


// Number.isNaN()으로 확인하는 것을 권장한다.
console.log(Number.isNaN(NaN));   // → true
console.log(Number.isNaN(-NaN));   // → true
console.log(Number.isNaN(undefined));   // → false
console.log(Number.isNaN(null));   // → false
console.log(Number.isNaN({}));   // → false
console.log(Number.isNaN(+'12345'));   // → false
```

**✋ 주의**  
자바스크립트에는 양의 0과 음의 0이 있는데, 이들을 비교하면 모두 true 결과를 반환한다.

```
0 === -0;   // → true
0 == -0;   // → true
```

> \*\_👉 추가로  
> \*\_0, -0, NaN과 같은 값은 ES6에 도입된 예측 가능한 정확한 비교 결과를 반환하는 \*\*Object.is 메서드\*\*로 비교하는 것이 좋다.  
>

### 7-4. 삼항 조건 연산자

삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다.

> 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값

`var result = score >= 60 ? 'pass' : 'fail';`  
예시 코드에서 score의 값이 60이상이라면 result의 값은 'pass'를 반환하게 되고, 60미만이라면 'fail'을 반환하게 된다.  
삼항 조건 연산자 표현식은 if ...else문과 유사하지만, **삼항 조건 연산자 표현식**은 값처럼 사용할 수 있는 반면 **if ...else문**은 값처럼 사용할 수 없다는 차이가 있다.

### 7-5. 논리 연산자

논리 연산자(logical operator)는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다.

| 논리 연산자 | 의미        |
| :---------- | :---------- |
| \|\|        | 논리합(OR)  |
| &&          | 논리곱(AND) |
| !           | 부정(NOT)   |

- **논리 부정(!) 연산자는 언제나 불리언 값을 반환**하며, 피연산자가 불리언 값이 아니면 불리언 타입으로 **암묵적 타입 변환**된다.
- **논리합(||), 논리곱(&&) 연산자** 표현식은 피연산자 중 어느 한쪽으로 **단축평가**되어, 불리언 값을 반환할 수도 있고 아닐 수도 있다.

### 7-8. typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 "string", "number", "boolean", "undefined", "symbol", "object", "function" 7가지 문자열 중 하나를 반환한다.

```
typeof ' ';   // → "string"
typeof 1;   // → "number"
typeof NaN;   // → "number"
typeof true;   // → "boolean"
typeof undefined;   // → "undefined"
typeof Symbol();   // → "symbol"
typeof null;   // → "object"
typeof [];   // → "object"
typeof {};   // → "object"
typeof new Date();   // → "object"
typeof /test/gi   // → "object"
typeof function () {}   // → "function"

// 주의
/* 선언하지 않은 식별자를 typeof 연산자로 연산하면
   ReferrenceError가 아닌, undefined를 반환한다. */
typeof undeclared;   // → undefined
```

'null'의 데이터 타입은 'object'로 반환되는 등 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다는 점도 기억하자.

### 7-11. 연산자의 부수 효과

👉 다른 코드에 영향을 주는 부수 효과가 있는 연산자 : \`=\`, \`++\`/\`--\`, \`delete\`

## 🗂 ch08. 제어문

제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용되며, 코드의 실행 흐름을 인위적으로 제어할 수 있다.

### 8-1. 블록문

블록문은 **0개 이상의 문을 중괄호로 묶은 것**이다. 자바스크립트는 블록문을 **하나의 실행 단위**로 취급한다. 블록문은 단독으로 사용할 수도 있지만, 일반적으로 제어문이나 함수를 정의할 때 사용된다.

**✋ 주의**  
문의 끝에는 세미콜론(;)을 붙이는 것이 일반적이나, 블록문은 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론(;)을 붙이지 않는다.

```
// 블록문
{
    let a = 1;
    console.log(a);   // → 1
}

let a = 1;
console.log(a);   // → 1


// 제어문
var x = 1;
if (x < 10) {
    x++;
}

// 함수 선언문
function sum(a, b) {
    return a + b;
}
```

### 8-2. 조건문

조건문은 주어진 조건식의 평가 결과에 따라 **블록문의 실행을 결정**하며,  
조건식은 불리언 값으로 평가될 수 있는 표현식이다.

#### if ... else 문

if ... else 문의 조건식은 불리언 값으로 평가될 수 있어야 한다. 불리언 값이 아닌 값으로 평가되는 경우, 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정하게 된다.

```
if (조건식1) {
    // 조건식1이 true이면 이 코드 블록 실행
} else if (조건식2 - 옵션) {
    // 조건식 2가 true이면 이 코드 블록 실행
} else (옵션) {
    // 조건식1과 조건식2 모두 false이면 이 코드 블록 실행
}
```

대부분의 if ... else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.

**✋ 주의**  
삼항 조건 연산자는 '값'으로 평가되는 표현식을 만들기 때문에 변수에 할당할 수 있고, if ... else 문은 표현식이 아닌, 문이기 때문에 변수에 할당할 수 없다.

```
var num = 2;

// 0은 false로 취급된다.
var kind = num ? (num > 0 ? '양수' : '음수') : '영';

console.log(kind);   // → 양수
```

#### switch 문

switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 **실행 흐름을 옮긴다.** switch 문은 논리적 참/거짓 보다는 **다양한 상황에 따라 실행할 코드 블록을 결정**할 때 사용한다.

```
switch (표현식) {
    case 표현식 1:
        switch 문의 표현식과 표현식1이 일치하면 실행될 문;
        break;
    case 표현식 2:
        switch 문의 표현식과 표현식2가 일치하면 실행될 문;
        break;
    case 표현식 3:
        switch 문의 표현식과 표현식3이 일치하면 실행될 문;
        break;
    default:
        switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
        // default 문에서는 break 문 생략이 일반적
}
```

### 8-3. 반복문

반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행하고, 그 후 **조건식을 다시 평가하여 여전히 참인 경우 블록문을 다시 실행**한다. 이는 조건식 평가 결과가 **거짓이 나올 때까지 반복**된다.

#### for 문

가장 일반적으로 사용되는 for 문의 형태이다.

```
for (변수 선언문 또는 할당문; 조건식; 증감식) {
    // 조건식이 true인 경우 반복 실행될 문;
}
```

**for 문의 변수 선언문, 조건식, 증감식 모두 옵션**으로, 반드시 사용할 필요는 없다. 단, **어떤 식도 선언하지 않은 채 for 문을 사용하면 무한루프**가 된다.

`for ( ; ; ) { ... }`

#### while 문

가장 일반적으로 사용되는 while 문의 형태이다.

```
while (조건식) {
    // 조건식의 평가 결과가 true인 경우 반복 실행될 문;
}
```

for 문은 반복 횟수를 명확히 아는 경우, while 문은 반복 횟수가 불명확할 때 주로 사용한다.

#### do ... while 문

do ... while 문은 코드 블록을 먼저 실행하고, 조건식을 평가하기 때문에 **블록문을 무조건 한 번 이상 실행**한다.

```
do {
    // 조건식 평가 결과가 true인 경우 반복 실행될 문;
} while(조건식);
```

### 8-4. break 문

break 문은 **레이블 문, 반복문(for, for ... in, for ... of, while, do ... while) 또는 switch 문**의 코드 블록을 탈출한다. **이 외 블록문에 break 문을 사용하면 SyntaxError(문법 에러)**가 발생한다.

```
// outer라는 식별자가 붙은 레이블 for 문
outer: for (var i = 0; i < 3; i++) {
    for (var j = 0; j < 3; j++) {
        // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다.
        if (i + j === 3) break outer;
        console.log(`inner [${i}, ${j}]`);
    }
}

console.log("Done!");
```

레이블 문은 중첩된 for 문 외부로 탈출할 때는 유용하지만, 그 외의 경우에는 권장하지 않는다. 레이블 문을 사용하면 프로그램 흐름이 복잡해져 가독성이 나빠지고, 오류 발생 가능성이 높아지기 때문이다.

### 8-5. continue 문

continue 문은 반복문의 코드 블록 실행을 **현 시점에서 중단**하고, **반복문의 증감식으로 실행 흐름을 이동**시킨다.

## 🗂 ch09. 타입 변환과 단축 평가

### 9-1. 타입 변환

타입 변환에는 '명시적 타입 변환(또는 타입 캐스팅)'과 '암묵적 타입 변환(또는 타입 강제 변환)'이 있다. 암묵적 타입 변환은 개발자의 의도가 코드에 명백히 나타나지 않으므로 예측이 필요하다. 그렇지만, 예측 오류 가능성이 낮은 명시적 타입 변환만 사용하겠다는 논리는 옳지 않다. **`(10).toString()`보다 `10 + ''`이 더욱 간결하고 이해하기 쉬운 것처럼 문법을 잘 이해하고 있다면, 암묵적 타입 변환이 가독성 측면에서 더 좋은 경우도 있기 때문이다.** 따라서 다른 개발자가 작성한 코드를 정확히 이해할 수 있고, 내가 작성한 코드도 다른 개발자가 이해하기 쉽도록 동작 원리를 이해하고 사용할 수 있도록 해야겠다.

#### 9-2. 암묵적 타입 변환

자바스크립트는 가급적 에러를 발생시키지 않기 위해 표현식을 평가할 때 **코드 문맥을 평가하여 에러 발생 대신 암묵적 타입 변환을 하는 경우**가 있다. 암묵적 타입 변환은 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.

##### 문자열 타입으로 변환

문자열 타입으로 변환하는 동작에는 크게 **'템플릿 리터럴의 표현식 삽입'**과 **'+ 연산자 사용'**이 있다.

```
// 템플릿 리터럴의 표현식 삽입 사용
`1 + 1 = ${1 + 1}`   // → "1 + 1 = 2"

// + 연산자 사용
// 숫자 타입 → 문자열 타입으로 암묵적 변환
17 + ''   // → "17"
-17 + ''   // → "-17"
NaN + ''   // → "NaN"
Infinity + ''   // → "Infinity"

// 불리언 타입 → 문자열 타입으로 암묵적 변환
true + ''   // → "ture"

// null 타입 → 문자열 타입으로 암묵적 변환
null + ''   // → "null"

// undefined 타입 → 문자열 타입으로 암묵적 변환
undefined + ''   // → "undefined"

// 참고__ 심벌 타입은 문자열 타입으로 암묵적 변환 X
(Symbol()) + ''   // → TypeError: Cannot convert a Symbol value to a string

// 객체 타입
({}) + ''   // → "[object Object]
Math + ''   // → "[object Math]
[] + ''   // → ""
[10, 20] + ''   // → "10, 20"
(function(){}) + ''   // → "function(){}"
Array + ''   // → "function Array() { [native code] }"
```

##### 숫자 타입으로 변환

숫자 타입으로 변환하는 동작에는 크게 **'산술 연산자 사용'**과 **'비교 연산자 사용'**이 있다.

**✋ 주의**

- NaN 으로 평가되는 것: `객체`, `빈 배열이 아닌 배열`, `빈 문자열이 아닌 문자열`, `undefined`
- 0 으로 평가되는 것: `빈 문자열('')`, `빈 배열([])`, `null`, `false`
- 1 로 평가되는 것: `true`

```
// 산술 연산자 사용
// 문자열 타입 → 숫자 타입으로 변환
+'17'   // → 17
1 - '1'   // → 0
2 * '5'   // → 10
1 / 'one'   // → NaN

// 비교 연산자 사용
'1' > 0   // → true
'12' !== 12   // → true
'12' != 12   // → false
```

##### 불리언 타입으로 변환

**if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식**은 논리적 참/거짓으로 평가되어야 한다. 이럴 때 조건식이 불리언값이 아닌 경우, 자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다. 불리언 타입이 아닌 값을 **Truthy 값(참으로 평가되는 값)** 또는 **Falsy 값(거짓으로 평가되는 값)**으로 구분하여 암묵적 타입 변환을 한다.

- Truthy 값: Falsy 값 외의 모든 값
- Falsy 값: `false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''(빈 문자열)`

#### 9-3. 명시적 타입 변환

**'표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출'**하거나 **'빌트인 메서드 사용'** 그리고 **'암묵적 타입 변환을 이용'**하여 명시적 타입 변환을 할 수 있다.

##### 문자열 타입으로 변환

- String 생성자 함수를 new 연산자 없이 호출

```
// 숫자 타입 → 문자열 타입
    String(17);   // → "17"
    String(NaN);   // → "NaN"
    String(Infinity);   // → "Infinity"

    // 불리언 타입 → 문자열 타입
    String(true);   // → "true"
```

- Object.prototype.toString 메서드 사용

```
// 숫자 타입 → 문자열 타입
(17).toString();   // → "17"
(NaN).toString();   // → "NaN"
(Infinity).toString();   // → "Infinity"

// 불리언 타입 → 문자열 타입
(false).toString();   // → "false"
```

- 문자열 연결 연산자를 이용

```
true + '';   // → "true"
false + '';   // → "false"
```

##### 숫자 타입으로 변환

- Number 생성자 함수를 new 연산자 없이 호출

```
// 문자열 타입 → 숫자 타입
Number('12');   // → 12
Number('-1);   // → -1
Number('12.17');   // → 12.17

// 불리언 타입 → 숫자 타입
Number(true);   // → 1
Number(false);   // → 0
```

- parseInt, parseFloat 함수 사용 **(문자열만 숫자 타입으로 변환O)**

```
parseInt('17');   // → 17
parseInt('-12');   // → -12
parseFloat('12.17');   // → 12.17
```

**👉 추가로**  
`parseInt()` 는 문자열 인자를 파싱하여 특정 진수(수의 진법 체계에서 기준이 되는 값)의 정수를 반환하는 함수이다.

```
// parseInt(string, radix)  ← radix는 옵션
parseInt(10, 2);   // → 2   __ 2진수 10을 10진수로 변환: 2
parseInt(10, 8);   // → 8   __ 8진수 10을 10진수로 변환: 8
parseInt('0a', 16);   // → 10   __ 16진수 '0a'를 10진수로 변환: 10
```

- \+ 단항 산술 연산자 이용

```
// 문자열 타입 → 숫자 타입
+'0';   // → 0
+'-17';   // → -17
+'12.17';   // → 12.17

// 불리언 타입 → 숫자 타입
+true;   // → 1
+false;   // → 0
```

- \* 산술 연산자 이용

```
// 문자열 타입 → 숫자 타입
'0' * 10;   // → 0
'-1' * '1';   // → -1
'12.17' * 1;   // → 12.17

// 불리언 타입 → 숫자 타입
true * 1;   // 1
false * 10;   // 0
```

##### 불리언 타입으로 변환

- Boolean 생성자 함수를 new 연산자 없이 호출

```
// 문자열 타입 → 불리언 타입
Boolean('x');   // → true
Boolean('');   // → false
Boolean('true');   // → true

// 숫자 타입 → 불리언 타입
Boolean(1);   // → true
Boolean(0);   // → false
Boolean(NaN);   // → false
Boolean(Infinity);   // → true
Boolean(17);   // → true

// null 타입 → 불리언 타입
Boolean(null);   // → false

// undefined 타입 → 불리언 타입
Boolean(undefined);   // → false

// 객체 타입 → 불리언 타입
Boolean({});   // → true
Boolean([]);   // → true
```

- ! 부정 논리 연산자 두 번 사용

```
// 문자열 타입 → 불리언 타입
!!'x';   // → true
!!'';   // → false
!!'false';   // → true
!!'true';   // → true

// 숫자 타입 → 불리언 타입
!!0;   // → false
!!1;   // → true
!!12;   // → true
!!NaN;   // → false
!!Infinity;   // → true

// null 타입 → 불리언 타입
!!null;   // → false

// undefined 타입 → 불리언 타입
!!undefined;   // → false

// 객체 타입 → 불리언 타입
!!{};   // → true
!![];   // → true
```

### 9-4. 단축 평가

단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 생략하는 것이다.

#### 논리 연산자를 사용한 단축 평가

논리합(||) 또는 논리곱(&&) 연산자 표현식은 2개의 피연산자 중 어느 한쪽으로 평가되며, 피연산자를 타입 변환하지 않고 그대로 반환한다. 다음은 단축평가의 평가 규칙이다.

| 단축 평가 표현식    | 평가 결과 |
| :------------------ | :-------- |
| true \|\| anything  | true      |
| false \|\| anything | anything  |
| true && anything    | anything  |
| false && anything   | false     |

- 어떤 조건이 Truthy 값일 때, 논리곱(&&) 연산자 표현식으로 if 문을 대체할 수 있다.

```
var done = true;
var message = '';

// 주어진 조건이 true일 때
if (done) message = '완료';

// 논리곱(&&) 연산자 단축 평가로 if 문 대체
message = done && '완료';
console.log(message);   // → "완료"
```

- 어떤 조건이 Falsy 값일 때, 논리합(||) 연산자 표현식으로 if 문을 대체할 수 있다.

```
var done = false;
var message = '';

// 주어진 조건이 false 일 때
if (!done) message = '미완료';

// 논리합(||) 연산자 단축 평가로 if 문 대체
message = done || '미완료';
console.log(message);   // → "미완료"
```

**👉 추가로**  
단축 평가는 **객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조**하는 등의 상황에서 유용하게 사용된다.

```
/* 객체를 가리키기를 기대하는 변수의 값이 객체가 아닌, null 또는 undefined인 경우
   객체의 프로퍼티를 참조하면 타입 에러가 발생하여 프로그램이 강제 종료된다. */
var elem = null;
var value = elem.value;   // TypeError: Cannot read property 'value' of null

// 단축 평가를 사용하면 이 상황에서 에러 발생X
var elem2 = null;
// elem2이 null 또는 undefined와 같은 Falsy 값이라면 → elem2로 평가
// elem2이 Truthy 값이면 → elem2.value로 평가
var value2 = elem2 && elem2.value;   // → null
```

#### 옵셔널 체이닝 연산자

ES11(ECMAScript2020)에 도입된 개념으로 옵셔널 체이닝 연산자 `?.`는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

> **🧐 생각**  
> 아직 프로젝트 경험이 많다거나 실무를 접해보지 않아서 이 연산자가 유용한지 개념만 봐서는 잘 모르겠다. 블로그 포스팅 하나를 읽어봤는데, 일단 꼭 필요한 경우가 아니라면 사용하지 않아도 될 것 같다고 생각하기로 했다. 지금은 이런 개념이 있다는 걸 한 번 봤다는 정도로 넘어가기로!  
> 참고 : [https://yoo11052.tistory.com/168](https://yoo11052.tistory.com/168)

#### null 병합 연산자

ES11(ECMAScript2020)에서 도입된 null 병합 연산자 `??`는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다. null 병합 연산자는 변수에 기본값을 설정할 때 유용하다.

**✋ 주의**  
좌항의 피연산자가 null 또는 undefined이 아니라면, Falsy값일지라도 우항의 피연산자가 아닌 좌항의 피연산자를 그대로 반환한다.

```
var foo = '' ?? 'default string';
console.log(foo);   // → ""
```
