## 10장 객체리터럴

### 객체란?
자바스크립트는 객체 기반의 프로그래밍 언어이며,
원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식)은 모두 객체이다.

프로퍼티는 객체의 상태를 나타내는 값이다 - data
메서드는 프로퍼티를 참조하고 조작할 수 있는 동작 - behavior

객체 리터럴은 중괄호({...}) 내에 0개 이상의 프로퍼티를 정의한다.
만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.
```
 var person = {
 	name: 'Lee',
		sayHello: function() {
			console.log(`hello My name is ${this.name}.`);
		}
	};

 var empty = {}; // 빈 객체
 ```
중괄호는 코드블록을 의미한다고 했는데
객체 리터럴에서 중괄호는 코드 블록을 의미하는 것이 아니므로 세미콜론을 붙여야한다.

객체 리터럴을 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식이다.
객체를 생성하기 위해 클래스를 먼저 정의하고 new 연산자와 함께 생성자를 호출할 필요가 없다.

객체 리터럴에 프로퍼티를 포함시켜 객체를 생섬함과 동시에 프로퍼티를 만들수도 있고
생성 이후에 동적으로 추가할 수 있다.

### 프로퍼티
객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.
```
ver person = {
  name: 'Lee', // 키는 name, 값은 'Lee'
  age: 20 // 키는 age, 값은 20
  ```
프로퍼티를 나열할때는 쉼표(,)로 구분한다.
일반적으로 마지막 프로퍼티에는 쉼표를 사용하지 않지만 사용해도 좋다.

프로퍼티 키는 빈 문자열을 포함하는 모든 문자열 또는 심벌 값을 말함
프로퍼티 값은 자바스크립트에서 사용할 수 있는 모든 값을 말함
프로퍼티 키는 프로퍼티 값에 접근할 때 필요한 식별자 역할을 한다.

심벌 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다.
```
var person = {
	 firstName: 'Ung-mo', // 식별자 네이밍 규칙 준수
  'last-name': 'Lee', // 식별자 네이밍 규칙 미준수
}
```
위 코드에서 식별자 네이밍 규칙을 미준수한 프로퍼티 키에서 따옴표를 생략하면
연산자가 있는 표현식으로 해석한다.

문자열 또는 문자열로 평가할 수 있는 표현식을 사용해
프로퍼티 키로 사용할 표현식을 대활호로 묶으면
프로퍼티 키를 동적으로 생성할 수도 있다.
```
var obj = {};
var key = 'hello';

// ES5: 프로퍼티 키 동적 생성
obj[key] = 'world';
```
빈 문자열을 프로퍼티 키로 사용해도 되지만 키로서 의미를 가지지는 못한다.
```
var foo = {
	'': '',
}

console.log(foo);// {"":""}
```
프로퍼티키에 문자열이나 심벌 값 이외의 값을 사용하면
암묵적 타입 변환을 통해 문자열이 된다.
따옴표는 붙지 않지만 내부적으로는 문자열로 변환된다.
```
var foo = {
  0: 1,
  1: 2,
  2: 3,
},
console.log(foo); // {0: 1, 1: 2, 2: 3}
```
이미 존재하는 프로퍼티 키를 중복 사용하면 나중에 선언한 프로퍼티가
먼저 선언된 프로퍼티를 덮어쓴다.
이 것은 에러가 발생하지 않으니 주의해야한다.
```
var foo ={
   name: 'lee',
   name: 'kim',
};
console.log(foo); // {name: 'kim'}
```
### 메서드
자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다.
아직 살펴보진 않았지만 자바스크립트의 함수는 일급 객체다.
따라서 함수는 값으로 취급할 수 있기 때문에 프로퍼티로도 사용할 수 있다.

프로퍼티 값이 함수일 경우,
일반 함수와 구분하기 위해 메서드(method)라고 부른다.
즉 메서드는 객체에 묶여있는 함수를 말한다.
```
var circle = {
	radius: 5, // 프로퍼티
  // 원의 지름
	getDiameter: function (){
		return 2 * this.radius; // this는 circle를 가리킨다.
 }
};
```
메서드 내부에 사용한 this 키워드는 객체 자신을 가리키는 참조변수다.

프로퍼티 접근
마침표 프로퍼티 접근 연산자(.) 사용
대활표 프로퍼티 접근 연산자([...]) 사용
```
var person = {
  name: "lee"
};

// 마침표 표기법
console.log(person.name);
// 대괄표 표기법
console.log(person['name']); 
```
대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싸야한다.
예외적으로 문자열이 모두 숫자로 이루어진 경우 따옴표를 생략할 수 있다.
```
var person = {
  name: "lee"
};
consoel.log(person[name]); // ReferenceError: name is not defined
```
위 예제에서 에러가 발생한 이유는 대괄호 연산자 내의 따옴표로 감싸지 않은 이름.
식별자 name을 평가하기 위해 name을 찾았지만 찾지 못했기 때문이다.

만약 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다.
이때 ReferenceError가 발생하지 않는다.
```
var person = {
  name: "lee"
};
console.log(person.age); // undefined
var person = {
	'last-name': 'lee',
	1: 10
};

person.'last-name'; //SyntaxError: Unexpected String
person.last-name; // 브라우저 환경: NaN
				  // Node.js 환경: ReferenceError: name is not defined
person[last-name]; // ReferenceError: last is not defined
person['last-name']; // lee

//프로퍼티 키가 숫자로 이뤄진 문자열인 경우 따옴표를 생략할 수 있다.
person.1; // SyntaxError: Unexpected number
person.'1'; // SyntaxError: Unexpected string
person[1]; // 10: person[1] -> person['1']
person['1']; // 10
```
위 예제에서 person.last-name의 실행결과는 node.js 환경과 브라우저 환경에서
결과 값이 다르다.

자바스크립트 엔진은 먼저 person.last를 평가한다.
person 객체에서 프로퍼티 키가 없기 때문에 person.last는 undefined로 평가된다.
따라서 undefined-name 으로 평가되고
name이라는 식별자를 찾는다. 이때 name은 프로퍼티키가 아닌 식별자로 해석된다.

Node.js 환경에서는 현재 어디에도 name이라는 식별자(변수, 함수 등의 이름) 선언이
없으므로 ReferenceError: name is not defined 라는 에러가 발생한다.

브라우저 환경에서는 name이라는 전역 변수(전역 객체 window의 프로퍼티)가
암묵적으로 존재한다.
전역 변수 name은 창(window)의 이름을 가리키며, 기본 값은 빈문자열이다.
따라서 person.last-name은 undefined-''과 같으므로 NaN이 된다.

프로퍼티 값 갱신
이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.
```
var person = {
  name: "lee"
};

person.name = 'kim'
console.log(person); // {name: 'kim'}
```


## 11장 원시 값과 객체의 비교
### 원시 값
변경 불가능한 값
원시 타입primitive type의 값은 변경 불가능한 값immutable value이다. 한번 생성된 원시값은 읽기 전용read only값으로서 변경할 수 없다.
변경 불가능 하다는 것은 변수가 아니라 값에 대한 진술이다.
변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있다.
변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 값의 이러한 특성을 불변성immutability라고 한다.

문자열과 불변성
ECMAScript 사양에 따르면 원시 타입의 크기를 아래와 같이 규정하고 있다.
문자열 타입은 2바이트, 숫자 타입은 8바이트 이다.
이외의 원시 타입은 규정되어 있지 않아 브라우저 제조사의 구현에 따라 다를 수 있다.
```
// 문자열은 0개 이상의 문자들로 이뤄진 집합이다.
var str1 = '';      // 0개의 문자로 이뤄진 문자열(빈 문자열)
var str2 = 'Hello'; // 5개의 문자로 이뤄진 문자열
var str = 'Hello';
str = 'world';
```
첫 번째 문이 실행되면 문자열 'Hello'가 생성되고 식별자 str은 문자열 'Hello'가 저장된 메모리 공간의 첫 번째 메모리 셀 주소를 가리킨다.
그리고 두 번째 문이 실행되면 이전에 생성된 문자열 Hello를 수정하는 것이 아니라 새로운 문자열 world를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 'Hello'와 'world'는 모두 메모리에 존재한다.
식별자 str은 문자열 'Hello'를 가리키고 있다가 문자열 'world'를 가키리도록 변경되었을 뿐이다.

유사 배열 객체
유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.
문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접글할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for문으로 순회할 수 도 있다.

원시값과 래퍼 객체
마침표 표기법(또는 대괄호 표기법)으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 준다. 즉, 원시값을 객체 처럼 사용하면 자바스크립트 엔진이 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출한다. 작업을 마친 후 다시 원시값으로 되돌린다.
```
const str = 'hello';

// 원시 타입인 문자열이 프로퍼티와 메서드를 갖고 있는 객체처럼 동작한다.
console.log(str.length); // 5
console.log(str.toUpperCase()); // HELLO
const str = 'hi';

// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.
console.log(str.length); // 2
console.log(str.toUpperCase()); // HI

// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.
console.log(typeof str); // string
```
위 예제에서 str.toUpperCase()이 부분을 풀어서 보면 아래와 같이 temp객체를 만들어서
String 생성자 함수로 임시 객체를 만들고 String객체가 가지고 있는 toUpperCase()함수를 사용해 그 결과를 리턴해 주는식으로 동작한다.

### 객체
자바스크립트 객체는 프로퍼티의 개수가 정해져 있지 않고, 동적으로 추가되고 삭제 가능하다. 또한 프로퍼티의 값에도 제약이 없다.
원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

객체의 관리 방식
java, c++같은 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체를 생성한다. 객체가 생성된 이후에는 프로퍼티를 삭제하거나 추가할 수 없다.
하지만 자바스크립트는 클래스 없이 객체를 생성할수 있으며, 생성된 이후에도 동적으로 프로퍼티와 메서드를 추가할 수 있다.
v8 자바스크립트 엔진에서는 히든 클래스hidden class라는 방식을 사용해 c++객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.

변경 가능한 값
객체 타입의 값, 즉 객체는 변경 가능한 값mutable vlaue이다.
```
var person = {
  name: 'Lee'
};
```
person 변수는 참조 값에 접근할 수 있는 메모리 주소를 기억하고 있다.

원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다.
하지만 객체를 할당한 변수person를 참조하면 메모리에 저장되어 있는 참조 값(0x00...1)을 통해 실제 객체{name: 'LEE'}에 접근한다.
```
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
var person = {
  name: 'Lee'
};

// person 변수에 저장되어 있는 참조값으로 실제 객체에 접근해서 그 객체를 반환한다.
console.log(person); // {name: "Lee"}
```

얕은 복사와 깊은 복사
얕은 복사는 객체의 한 단계까지만 복사하는 것을 말하고,
깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.
```
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o }; // 35장 "스프레드 문법" 참고
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash');
// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

참조에 의한 전달
여러개의 식별자가 하나의 객체를 공유할 수 있다는 것은 객체를 가리키는 변수person를 다른 변수copy에 할당하면 원본의 참조 값이 복사되어 전달된다는 것이다.
```
var person = {
  name: 'Lee'
};

// 참조값을 복사(얕은 복사). copy와 person은 동일한 참조값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```

## 12장 함수
### 함수란?
함수는 자바스크립트에서 가장 중요한 핵심 개념이다.
스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화등이 모두 함수와 깊은 관련이 있다.

f(x,y) = x + y를 자바스크립트의 함수로 표현해 보자
```
// f(x, y) = x + y
function add(x, y) {
  return x + y;
}

// f(2, 5) = 7
add(2, 5); // 7
```
프로그래밍 언어의 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
함수는 아래 3가지로 이루어져 있다.

매개변수 parameter
인수 argument
반환값 return value

함수는 함수 정의function definition를 통해 생성한다.
```
// 함수 정의
function add(x, y) {
  return x + y;
}
```
함수는 정의만으로 실행되지 않는다.
인수parameter를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시해야 한다.
이를 함수 호출function call/invoke라고 한다.
```
// 함수 호출
var result = add(2, 5);

// 함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환한다.
console.log(result); // 7
```

### 함수를 사용하는 이유
- 코드의 재사용성에 유용하다.
- 유지보수의 편의성을 높인다.
- 코드의 신뢰성을 높인다.
- 코드의 가독성을 향상 시킨다.


### 함수 리터럴
자바스크립트의 함수는 객체 타입의 값이다.
따라서 숫자 값을 숫자 리터럴로 생성하고, 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있다.
(함수 리터럴 === 함수 표현식)
```
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```

함수 리터럴의 구성

function키워드
함수 이름
매개 변수 목록
함수 몸체
구성요소	설명
함수 이름	- 함수 이름은 식별자다
- 함수이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.
- 함수 이름은 생략할 수 있다.(익명함수)
매개 변수 목록	- 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분
- 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다.
- 매개변수는 함수 몸체 내에서 변수와 동일, 식별자 네이밍 규칙을 준수 해야한다.
함수 몸체	- 함수가 호출되었을 때 실행될 문들을 하나의 실행 단위로 정의한 코드 블록
- 함수 호출에 의해 실행된다.

함수 리터럴은 값을 생성하기 위한 표기법이다.
함수 리터럴은 평가되어 값을 생성하고, 이 값은 객체다.
함수는 객체다.

함수와 일반 객체는 다르다.
일반 객체는 호출할 수 없지만, 함수는 호출할 수 있다.


### 함수 정의
함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 반환할 값을 지정하는 것을 말한다.
정의된 함수는 평가되어 함수 객체가 된다.

함수를 정의하는 4가지 방법

함수 정의 방식	예시
```
함수 선언문	function add(x,y){
return x+y;
}
함수 표현식	var add = function(x,y){
return x+y;
};
Function 생성자 함수	var add = new Function('x','y','x+y');
화살표 함수(ES6)	var add = (x,y)=>x+y
```

함수 선언문
```
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 참조
// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.
// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.
console.dir(add); // ƒ add(x, y)
```

함수 선언문은 표현식이 아닌 문이다.
크롬 개발자 도구의 콘솔에서 함수 선언문을 실행하면 완료값 undefined가 출력된다.
함수 표현식은 표현식이 평가되어 생성된 함수가 출력된다.

함수 선언문과 함수 표현식(함수 리터럴) 차이
함수 선언문은 함수 이름을 생략할 수 없다.
자바스크립트 엔진은 함수 선언문을 해석해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

함수 표현식(함수 리터럴)은 별도로 변수에 할당받지 않은 이상 호출할수 있는 식별자가 없다.

함수 표현식(=함수 리터럴)
자바스크립트의 함수는 일급 객체이다.
일급 객체는 값처럼 변수에 할당할 수 있고, 프로퍼티 값이 될수도 있으며, 배열의 요소도 될 수 있다.
이러한 함수의 정의 방식을 함수 표현식 function expression이라고 한다.
```
// 함수 표현식
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

함수 리터럴의 함수 이름은 생략할 수 있다. 이러한 함수를 익명 함수라 한다.
함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.

4.3 함수 생성 시점과 함수 호이스팅
함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.
```
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```
함수 선언문은 런타임 이전에 함수 객체가 먼저 생성된다. 그리고 함수 이름과 동일한 이름으로 식별자를 생성하고 생성된 함수 객체를 할당한다.
즉, 코드가 실행되는 런타임시점에는 이미 함수 객체가 생성되어 있고 식별자에 할당까지 완료된 상태이다.
따라서 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하며 이를 함수 호이스팅이라고 한다.

- 함수 선언문은 코드(함수 선언문을 포함한) 평가 단계에서 함수 객체 생성.
- 함수 표현식은 코드(함수 표현식을 포함한) 실행 단계에서 함수 객체 생성.

Function 생성자 함수
자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new연산자와 함께 호출하면 함수 객체를 생성해서 반환한다.(new연산자 없이 호출해도 결과는 동일)
```
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```
Function생성자 함수로 함수를 생성하는 방식은 권장되지 않는다.
클로저(closure)가 생성되지 않는다.

5.함수 호출
함수는 함수를 가리키는 식별자와 한 쌍의 소괄호()인 함수 호출 연산자로 호출한다.
함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다. 이때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행되기 시작한다.
```
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 호출
// 인수 1과 2는 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.
var result = add(1, 2);
```
함수 매개변수의 스코프는 함수 내부이다.

### 반환문의 역할

함수의 실행을 중단하고 함수 몸체를 빠져나감.
```
function multiply(x, y) {
  return x * y; // 반환문
  // 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.
  console.log('실행되지 않는다.');
}
```
### 중첩 함수
중첩 함수(nested function)또는 내부 함수(inner function)라 한다. 그리고 중첩 함수를 포함하는 함수는 외부 함수(outer function)라 한다.
```
function outer() {
  var x = 1;

  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); // 3
  }

  inner();
}

outer();
```
ES6부터는 함수 선언문을 if문이나 for문 등의 코드 블록 내에서도 정의할 수 있다.
(호이스팅으로 인해 혼란이 발생할 수 있으므로 바람직하지 않다.)

### 콜백 함수
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 한다.
매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.
```
// n만큼 어떤 일을 반복한다
function repeat(n) {
  // i를 출력한다.
  for (var i = 0; i < n; i++) console.log(i);
}

repeat(5); // 0 1 2 3 4
```
위 예제를 아래와 같이 변경하여 공통적으로 수행하는 일을 미리 정의해 재사용할 수 있다.
```
// 외부에서 전달받은 f를 n만큼 반복 호출한다
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); // i를 전달하면서 f를 호출
  }
}

var logAll = function (i) {
  console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logAll); // 0 1 2 3 4

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logOdds); // 1 3
```
