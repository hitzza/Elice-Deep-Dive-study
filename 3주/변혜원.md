## 10장 객체 리터럴
> ### 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.             
식별자 네이밍 규칙을 따르지않는 이름에는 반드시 "따옴표"를 사용해야 한다.       
*프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌값<br>
*프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값<br><br> 

```javascript
var person = {
  firstName: 'Hye-won', //식별자 네이밍 규칙을 준수하는 프로퍼티 키
  'last-name': 'Byun' //식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키
};
```
<br>
자바스크립트 엔진은 따옴표를 생략한 last-name을 - 연산자가 있는 표현식으로 해석한다.<br><br>

프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다. 예를 들어, 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않았지만 내부적으로는 문자열로 변환된다.<br><br>

> ### 메서드
>프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드(method)라 부른다. 즉, 메서드는 객체에 묶여 있는 함수를 의미한다.

자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다. 자바스크립트의 함수는 (일급)객체이다. 따라서 함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있다.<br><br>

> ### 프로퍼티 동적 생성
> 존재하지 않는 프로퍼티 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.
<br>

<br>

> ### 프로퍼티 삭제
> delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러 없이 무시된다.
```js
var person = {
  name: 'Byun' 
}; 

//프로퍼티 동적 생성
person.ag = 20;

//person 객체에 age프로퍼티가 존재한다.
// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 있다.
delete person.age;
```   

- - -
## 11장 원시 값과 객체의 비교

> ### 유사 배열 객체
> 유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할수도 있다.

<br>

> ###  얕은 복사(shallow copy)와 깊은 복사(deep copy)
> 객체를 프로퍼티 값으로 갖는 객체의 경우 얕은 복사는 한단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.
> ```js
>  const o = { x : { y : 1} };
>
>  //얕은 복사
>  const c1 = { ...o }; //"스프레드 문법" 참고
>  console.log(c1 === o); //false
>  console.log(c1.x === o.x); //true
>
> //깊은 복사
> //lodash를 설치한 후, Node.js 환경에서 실행
>  const c2 = _.cloneDeep(o);
>  console.log(c2 === c2); //false
>  console.log(c2.x === o.x); //false
> ```
> 얕은 복사와 깊은 복사로 생성된 객체는 원본과 참조값이 다른 별개의 객체다. 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.




- - -
## 12장 함수
> ### 함수 정의 방법   

1. 함수 선언문
```js
function add(x,y) {
  return x + y;
}
```
함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 이름을 생략할 수 있으나 **함수 선언문은 함수 이름을 생략할 수 없다.**  

<br>

2. 함수 표현식
```js
var add = function(x,y) {
  return  x + y;
};
```
함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라 한다. 하지만 함수 선언문과 함수 표현식이 정확히 동일하게 동작하지는 않는다.

<br>

3. Function 생성자 함수
```js
var add = new Function('x', 'y', 'return x+y');
```
Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.

<br>

4. 화살표 함수(ES6)
```js
var add = (x,y) => x + y;
```
화살표 함수는 function 키워드 대신 화살표 => 를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다.

<br>

> ### 반환문
> 함수는 return 키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있다.

1. 반환문의 첫번째 역할   
반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.   

2. 반환문의 두번째 역할   
반환문은  return 키워드 뒤에 오는 표현식을 평가해 반환한다. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.

> ### 재귀함수
> 함수가 자기 자신을 호출하는 것을 재귀 호출이라한다. 재귀 함수는 재귀 호출을 수행하는 함수를 말한다.

재귀 함수는 반복되는 처리를 위해 사용한다.
```js
function countdown(n) {
  for (var i = n; i >= 0; i--){
    console.log(i);
  }
}
```
재귀함수를 사용한다면 반복문 없이도 위의 함수를 구현할 수 있다.
```js
function countdown(n) {
  if (n < 0) return;
  console.log(n);
  countdown(n - 1); //재귀 호출
}
```
재귀 함수는 자신을 무한 재귀 호출한다. 따라서 **탈출 조건을 반드시** 만들어야 한다. 재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 위험이 있어 주의해서 사용해야 한다.