> ## 13장 스코프

> ### 스코프(scope)란?    
> 스코프(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다.
> 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 한다.
> 즉, 스코프는 식별자가 유효한 범위를 말한다.

var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.   
하지만 let이나 const 키워드로 선언된 변수는 같은 스코프내에서 중복 선언을 허용하지 않는다.   

변수는 자신이 선언된 위치(전역 또는 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다.      

전역 변수는 어디서든 참조할 수 있으므로 함수 내부에서도 참조할 수 있다. **전역이란 코드의 가장 바깥 영역을 말한다.**   

지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다. **지역이란 함수 몸체 내부를 말한다.**   

> ### 스코프 체인이란?   
> 모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프다.

변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 **상위 스코프 방향**으로 이동하며 선언된 변수를 검색한다.   

> ### 함수 레벨 스코프란?    
> 지역은 함수 몸체 내부를 말한다. 이는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미이다.

var 키워드는 함수 {몸체}만을 지역 스코프로 인정한다. 따라서 for문에서 반복을 위해 선언된 i 변수는 전역 변수가 된다.

> ### 렉시컬 스코프(또는 정적 스코프)란?    
> 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.
> 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.
---
> ## 14장 전역 변수의 문제점

1. 암묵적 결합     
   * 모든 코드가 전역 변수를 참조하고 변경할 수 있는 것을 허용한다.    
   * 변수의 유효 범위가 크면 클수록 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.<br><br>
3. 긴 생명 주기
   * 전역 변수는 생명주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다.
   * 전역 변수의 상태를 변경할 수 있는 시간도 길고 기회도 많다.<br><br>
5. 스코프 체인 상에서 종점에 존재
   * 변수를 검색할 때 가장 마지막에 검색된다는 것을 말한다. 즉, 전역 변수의 검색속도가 가장 느리다.<br><br>
7. 네임스페이스 오염
   * 자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것이다.
   * 다른 파일 내에 동일한 ㄴ이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

---
> ## 15장 let, const 키워드와 블록 레벨 스코프

> ### var 키워드로 선언한 변수의 문제점
1. 변수 중복 선언 허용          
   만약 동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 변수를 중복선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 변경되는
   부작용이 발생한다.
   <br><br>
2. 함수 레벨 스코프
   var 키워드로 선언한 변수는 오로지 함수의 {코드 블록}만을 지역 스코프로 인정한다. for문의 변수 선언문에서 var 키워드로 선언한 변수도 전역 변수가 된다.
   ```js
   var i = 10;
   for ( var i = 0; i < 5; i++) {
     console.log(i); // 0 1 2 3 4
    }
    console.log(i); // 5
   ```
이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생한다. 
<br><br>
3. 변수 호이스팅                          
변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수 참조시 undefined를 반환한다.                 
변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지 않지만 프로그램의 흐름상 맞지 않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 수 있다.
<br><br>
> ### let 키워드                                                  
1. 변수 중복 선언 금지         
   let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러가 발생한다.
<br><br>
2. 블록 레벨 스코프       
   var 키워드는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.
   하지만 let 키워드로 선언한 변수는 모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정한다.
<br><br>
3. 변수 호이스팅         
   let 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것처럼 동작한다.
   초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러가 발생한다.
<br><br>
> ### const 키워드
1. 선언과 초기화         
   const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야한다. 그렇지 않으면 문법 에러가 발생한다.
<br><br>
2. 재할당 금지
   const 키워드로 선언한 변수는 재할당이 금지된다.
<br><br>
3. 상수            
   const 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고, 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.
```js
const TAX_RATE = 0.1;
let preTaxPrice = 100;
let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);
```
상수는 프로그램 전체에서 공통적으로 사용하므로 나중에 세율이 변경되면 상수만 변경하면 되기 때문에 유지보수성이 향상된다.
<br><br>
4. const와 객체           
const 키워드로 선언된 객체를 할당한 경우 값을 변경할 수 있다. 객체는 재할당 없이도 직접  변경이 가능하기 때문이다.
```js
const fruit = {
  name: 'apple'
};
fruite.name = 'banana';
console.log(fruit); // {name: 'banana'}
```
<br><br>
> ### var vs let vs const
변수를 선언할 때는 일단  const키워드를 사용하자. 재할당이 필요하다면 그때 const 키워드를 let키워드로 변경해도 늦지 않다.
   
