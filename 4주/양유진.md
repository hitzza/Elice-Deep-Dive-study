## 🗂 ch.13 스코프

### 13.1 스코프란?

스코프(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념으로, **변수 그리고 함수와 깊은 관련**이 있다. 그러니 개념을 제대로 잡고 가는 것이 중요하겠다!

> 🔎 **스코프란?** > **식별자(변수 이름, 함수 이름, 클래스 이름 등)가 유효한 범위**를 말한다. 모든 식별자는 <u>자신이 선언된 위치에 의해</u> 다른 코드가 식별자 자신을 참조할 수 있는 스코프가 결정된다.

스코프는 **자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙**이라고도 할 수 있다. JS 엔진은 코드를 실행할 때 코드의 문맥을 고려한다.

- 렉시컬 환경: "코드가 어디에서 실행되며 주변에 어떤 코드가 있는지"를 말한다.
- 실행 컨텍스트: 렉시컬 환경을 구현한 것으로, 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.
  <br>

```
var x = 'global';

function foo() {
	var x = 'local';
	console.log(x);     // (1)
}

foo();

console.log(x);     // (2)
```

위 예제 코드에는 총 2개의 'x'라는 변수가 있다. (1)과 (2)가 실행될 때 어떤 'x' 변수가 참조될지, 자바스크립트 엔진은 렉시컬 환경을 고려하게 된다. 결과는 (1) 'local', (2) 'global'이다. foo 함수 내부에서 선언된 x 변수는 해당 함수 내부가 자신의 스코프이고, (2)에서는 함수 내에 선언된 변수 x를 참조할 수 없다.

또한 스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있다. **스코프 내에서 식별자는 유일해야 하지만, 다른 스코프에는 같은 이름의 식별자 사용이 허용된다.**

> **➕ var, let, const 로 선언한 변수의 중복 선언**

- var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용되는데, 이는 의도치 않은 변수값 재할당의 부작용이 발생할 수 있다.

```
function foo() {
	var x = 1;
	var x = 2;     // 같은 스코프 내 중복 선언 허용
	console.log(x);     // 2
}
foo();
```

>

- let, const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 불가하다.

```
function var() {
	let x = 1;
	// 같은 스코프 내 중복 선언 허용X
	let x = 2;     // Syntax Error: Identifier 'x' has already been declared
}
bar();
```

<br>

### 13.2 스코프의 종류

| 구분 | 설명                  | 스코프      | 변수      |
| ---- | --------------------- | ----------- | --------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부        | 지역 스코프 | 지역 변수 |

- 전역 변수는 코드 내 어디서든지 참조할 수 있다.
- 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

<br>

### 13.3 스코프 체인

> **🔎 스코프 체인이란?**
> 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다. 이렇게 **스코프가 계층적으로 연결된 것**을 스코프 체인이라고 한다.

<img src="https://velog.velcdn.com/images/djavoa99/post/ab8f423f-fc98-4e0a-b706-f9707cb1ed7c/image.png" alt="스코프체인 그림" style="width: 200px;" />

- 모든 스코프는 하나의 계층적 구조로 연결된다.
- 모든 스코프의 **최상위 스코프**는 **전역 스코프**이다.
- 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 **단방향**으로 연결한 것이다.
  - <u>전역 렉시컬 환경</u>은 코드가 로드되면 생성된다.
  - <u>함수의 렉시컬 환경</u>은 함수가 호출되면 생성된다.

식별자를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 식별자가 참조하는 코드의 스코프에서 시작하여 **상위 스코프 방향으로 이동하며 선언된 식별자를 검색**한다. 따라서 **상위 스코프에서 유효한 식별자는 하위 스코프에서 자유롭게 참조할 수 있지만, 하위 스코프에서 유효한 식별자를 상위 스코프에서 참조할 수 없다.**

<br>

### 13.4 함수 레벨 스코프

- **블록 레벨 스코프**: 함수 뿐만 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든다.
- **함수 레벨 스코프**: 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.

ES6 이전의 자바스크립트는 변수를 `var` 키워드로 선언했는데, 이때 함수 레벨 스코프 특성을 가졌다.

```
var i = 10;

for(var i = 0; i < 5; i++) {
	console.log( i );     // 0 1 2 3 4
}
```

위 예제 흐름에서 블록 레벨 스코프의 경우라면 for 문에서 반복을 위해 선언된 i 변수는 for 문 내에서만 유효한 지역 변수이다.
하지만 `var` 키워드로 선언된 변수는 이를 인정하지 않기 때문에 i 변수는 전역 변수가 된다. 따라서 전역 변수 i는 중복 선언되고, 의도치 않은 전역 변수의 값이 재할당된다.

🤓 ES6에서 도입된 `let`, `const` 키워드는 블록 레벨 스코프를 지원한다.

<br>

### 13.5 렉시컬 스코프

- **동적 스코프**: <u>함수를 어디에서 **호출**</u>했는지에 따라 함수의 상위 스코프 결정
- **렉시컬 스코프 (또는 정적 스코프)**: <u>함수를 어디에서 **정의**</u>했는지에 따라 함수의 상위 스코프 결정

자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디에서 정의했는지에 따라 상위 스코프를 결정한다. **함수의 상위 스코프는 함수 정의(함수 선언문 또는 함수 표현식)가 실행될 때 정적으로 결정되는데, 함수 정의가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문**이다.

```
var x = 1;

function foo() {
	var x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo();     // 1
bar();     // 1
```

➕ "렉시컬 스코프"는 "클로저"와 깊은 연관이 있다.

<br>

---

## 🗂 ch14. 전역 변수의 문제점

### 14.1 변수의 생명 주기

**▪️ 지역 변수의 생명 주기**

지역 변수의 생명 주기는 **함수의 생명 주기와 일치**한다.

<img style="width: 370px; background-color: #fff;" src="https://velog.velcdn.com/images/yvnji25/post/68907461-59e6-49ee-8003-229bf3f3f71f/image.png" alt="지역 변수의 생명 주기" />
<br>

✋ 함수 몸체 내부에서 선언된 지역 변수의 생명 주기는 함수의 생명주기와 대부분 일치하지만, 지역 변수가 함수보다 오래 생존하는 경우도 있다. 그리고 이는 스코프도 마찬가지이다.
&nbsp;&nbsp;&nbsp;&nbsp;➡️ 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;따라서 <u>변수의 생명 주기는 메모리 공간이 확보된 시점부터</u><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>공간이 해제되어 가용 메모리 풀에 반환되는 시점까지</u>이다.

<br>

**▪️ 전역 변수의 생명 주기**

`var` 키워드로 선언한 전역 변수의 생명 주기는 **전역 객체의 생명 주기와 일치**한다. (**+** `let`, `const` 키워드도 마찬가지이다.)

<img style="width: 530px; background-color: #fff;" src="https://velog.velcdn.com/images/yvnji25/post/adbf78e8-19a2-4c25-8bb3-b91784e4a5cf/image.png" alt="전역 변수의 생명 주기"/>
<br>

> **👉 전역 객체**

- 전역 객체는 <u>코드가 실행되기 이전 단계에</u> 자바스크립트 엔진에 의해 어떤 객체보다도 <u>가장 먼저 생성되는 특수한 객체</u>이다.
- 전역 객체는 <u>클라이언트 사이드 환경(브라우저)에서는 window</u>, <u>서버 사이드 환경(Node.js)에서는 global 객체</u>를 의미한다.
- 전역 객체의 프로퍼티에는 '표준 빌트인 객체(Object, Array, String, Number, Function 등)'와 환경에 따른 호스트 객체(클라이언트 Web API 또는 Node.js의 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수가 있다.

브라우저 환경에서 전역 객체는 window 이므로, <u>전역 객체 window는 웹 페이지를 닫기 전까지 유효하다.</u> 따라서 브라우저 환경에서 `var` 키워드로 선언한 전역 변수는 웹 페이지를 닫을 때까지 유효하다.

<br>

### 14.2 전역 변수의 문제점

- 암묵적 결합
  - 변수의 유효 범위가 크면 클수록 **코드의 가독성은 나빠지고**, **의도치 않게 상태가 변경될 수 있는 위험성**도 높아진다.
- 긴 생명 주기
  - 전역 변수는 생명 주기가 길기 때문에 메모리 리소스도 오랜 시간 소비한다.
  - 크지 않은 함수의 지역 변수의 생명 주기는 매우 짧다. 그만큼 오류 발생 확률도 낮고, 메모리 리소스도 짧은 시간 소비한다.
- 스코프 체인 상에서 종점에 존재
  - 전역 변수는 스코프 체인 상 종점에 존재하므로 가장 마지막에 검색된다. 즉, **전역 변수의 검색 속도가 가장 느리다.** 검색 속도의 차이가 크지는 않지만 분명히 있다.
- 네임스페이스 오염
  - 자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 하여도, 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에 동일한 이름으로 명명된 전역 변수/전역 함수가 같은 스코프 내에 존재한다면 의도/예상과 다른 결과를 가져올 가능성이 있다.'

<br>

### 14.3 전역 변수의 사용을 억제하는 방법

14.2에서 언급된 전역 변수의 문제점처럼 전역 변수의 무분별한 사용은 위험하다. 따라서, **전역 변수의 남발은 억제하고, 반드시 전역 변수를 사용해야 할 이유가 없다면 지역 변수를 사용해야 한다. 변수의 스코프는 좁을수록 좋다.**
<br>

**◾️ 즉시 실행 함수**
즉시 실행 함수는 단 한 번만 호출되는 함수이다. 모든 코드를 즉시 실행 함수로 감싸게 되면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 이 특성을 이용해 전역 변수의 사용을 제한할 수 있다.

```
(function() {
	var foo = 10;     // 즉시 실행 함수의 '지역 변수'
	// ...
}( ));

console.log(foo);     // ReferenceError: foo is not defined
```

이 방법을 사용하면 전역 변수를 생성하지 않으므로, 라이브러리 등에 자주 사용되는 방법이다.
<br>

**◾️ 네임스페이스 객체**
전역에 네임스페이스 역할을 할 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다. 네임스페이스 객체 내에 또 다른 네임스페이스 객체를 프로퍼티로 추가하여 계층적으로 구성할 수도 있다.

```
var MYAPP = {};     // 전역 네임스페이스 객체

MYAPP.person = {
	name: 'Lee',
	address: 'Seoul'
};

console.log(MYAPP.person.name);     // Lee
```

식별자 충돌 방지 효과는 있지만, 네임스페이스 객체 자체가 결국 전역 변수에 할당되므로 그다지 유용해 보이지는 않는 방법이다.
<br>

**◾️ 모듈 패턴**
모듈 패턴은 클래스를 모방하여 관련 있는 변수와 함수를 모아 "즉시 실행 함수"로 감싸서 하나의 모듈을 만드는 방식으로, 클로저 기반으로 동작한다. 이 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다는 것이다.

> **🔎 캡슐화**
> 캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데, 이를 '정보 은닉'이라 한다.

자바스크립트는 public, private, protected 등의 접근 제한자를 제공하지 않아 정보 은닉이 한정적으로 구현된다.

```
var Counter = (function ( ) {
	// private 멤버
	var num = 0;

	// 반환되는 객체의 프로퍼티는 외부에 노출되는 public 멤버
	return {
		increase() {
			return ++num;
		},
		decrease() {
			return --num;
		}
	};
}( ));

// private 변수는 외부로 노출되지 않음
console.log(Counter.num);     // undefined

console.log(Counter.increase());     // 1
console.log(Counter.increase());     // 2
console.log(Counter.decrease());     // 1
console.log(Counter.decrease());     // 0
```

<br>

**◾️ ES6 모듈**
**ES6 모듈에서는 더이상 전역 변수를 사용할 수 없다.** ES6 모듈은 파일 자체의 독자적 모듈 스코프를 제공하기 때문이다.

ES6 모듈은 모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 사용할 수 있다. `<script>`태그에 `type="module"`을 추가하면, 로드된 자바스크립트 파일<span style="color: #d5d5d5;">(이때는 확장자로 '.mjs' 권장)</span>은 모듈로서 동작한다.

```
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```

ES6는 모던 브라우저에서 동작하기 때문에 IE를 포함한 구형 브라우저에서는 동작하지 않는다. 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.

<br>

---

<br>

## 🗂 ch15. let, const 키워드와 블록 레벨 스코프

### 15.1 var 키워드로 선언한 변수의 문제점

앞 장들에서 다룬 내용이지만, `var`키워드로 변수를 선언했을 때의 문제점을 모아 보기 위해 다시 적어보았다.

**◾️ 변수 중복 선언 허용**
`var`키워드로 선언한 변수는 중복 선언이 가능하다. 그중에서도 초기화문이 있는 변수 선언문이라면 먼저 선언된 변수 값이 변경되는 부작용이 발생된다.

```
var x = 1;
var y = 1;

var x = 100;
var y;     // 초기화문이 없는 변수 선언문은 무시된다.

console.log(x);     // 100
console.log(y);     // 1
```

<br>

**◾️ 함수 레벨 스코프**
`var`키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하기 때문에 함수 외부를 포함하여 for 문의 변수 선언문 등에서 모두 전역 변수가 된다.

```
var x = 1;

if(true) {
	var x = 10;
}

console.log(x);     // 10
```

함수 레벨 스코프는 **전역 변수를 남발할 가능성을 높이고, 이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우도 발생**한다.
<br>

**◾️ 변수 호이스팅**
변수 호이스팅에 의해 `var`키워드로 선언한 변수는 변수 선언문 이전에 참조했을 때, undefined를 반환하긴 하지만, 에러 발생 없이 참조가 가능하다.

```
// 변수 호이스팅에 의해 이미 foo 변수는 선언된 상태 (1. 선언 단계)
// 변수 foo 는 undefined로 초기화된다. (2. 초기화 단계)
console.log(foo);     // undefined

// 변수에 값 할당 (3. 할당 단계)
foo = 123;

console.log(foo);     // 123

// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행된다.
var foo;
```

변수 선언문 이전에 변수를 참조하는 것은 프로그램의 흐름상 맞지 않을 뿐더러, 가독성을 떨어뜨리고, 오류 발생의 여지를 남긴다.

<br>

### 15.2 let 키워드

`var`키워드와 `let`키워드의 차이를 중심으로 특징을 보자면

**◾️ 변수 중복 선언 금지**
`let`키워드로 이름이 같은 변수를 중복 선언하면 **문법 에러(Syntax Error)가 발생**한다.
<br>

**◾️ 블록 레벨 스코프**
`let`키워드로 선언한 변수는 모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```
let foo = 1;     // 전역 변수

{
	let foo = 2;     // 지역 변수
	let bar = 3;     // 지역 변수
}

console.log(foo);     // 1
console.log(bar);     // ReferenceError: bar is not defined
```

`let`키워드로 선언한 변수는 의도치 않은 값의 변경이 이루어지지 않고, 스코프를 벗어난 곳에서 참조하는 경우에는 오류(ReferenceError)가 발생된다.
<br>

**◾️ 변수 호이스팅**
`let`키워드로 선언한 변수는 **"선언 단계"와 "초기화 단계"가 분리되어 진행된다.** 즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만, **초기화 단계는 변수 선언문에 도달했을 때 실행된다.**

<div>
	<img style="width: 400px; margin-bottom: 20px;" src="https://velog.velcdn.com/images/rozley/post/727d8aca-2c9c-41c2-bfb5-2066efc30014/image.png" alt="var 키워드로 선언한 변수의 생명 주기"/>
	<img style="width: 400px;" src="https://velog.velcdn.com/images/rozley/post/b3c5ad50-3186-4b9e-825b-b5289a9ca881/image.png" alt="let 키워드로 선언한 변수의 생명 주기" />
</div>
이런 `let`키워드의 특성은 변수 호이스팅에서도 `var`키워드로 선언한 변수와의 차이를 볼 수 있다.

```
// var 키워드로 선언한 변수의 호이스팅

console.log(foo);     // undefined

foo = 123;

console.log(foo);     // 123

var foo;


// let 키워드로 선언한 변수의 호이스팅

let bar = 1;     // 전역 변수
{
	console.log(bar);     // ReferenceError: Cannot access 'bar' before initialization
	// 지역 변수 _ 지역 변수 bar 변수 자체는 런타임 이전에 존재
	//                초기화는 아래 코드라인에서 값 할당과 동시에 일어나므로
	//                아직 지역 변수 bar는 'undefined' 초기화 조차 이루어지지 않은 상태.
	let bar = 2;     // 이때 초기화 + 값 할당
}
```

<br>

**◾️ 전역 객체와 let**
`var`키워드로 선언한 전역 변수, 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때는 window를 생략할 수 있다.

```
// 전역 변수
var x = 1;
// 암묵적 전역
y = 2;
// 전역 함수
function foo() {}

// 아래 두 코드는 동일한 동작이다.
console.log(window.x); // 1
console.log(x); // 1

console.log(window.y); // 2
console.log(y); // 2

console.log(window.foo); // foo() {}
console.log(foo); // foo() {}
```

<br>

`let`키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니므로, `window.foo`와 같은 방식으로 접근할 수 없다. `let` 전역 변수는 보이지 않는 개념적인 블록 내에 존재한다.

```
let x = 1;

console.log(window.x); // undefined
console.log(x); // 1
```

<br>

### 15.3 const 키워드

`const`키워드는 상수(constant)를 선언하기 위해 많이 사용된다. 이 키워드의 특징은 `let`키워드와 대부분 동일하여 차이점을 중심으로 보자면

**◾️ 선언과 초기화**
**`const`키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.** 그렇지 않으면 문법 에러(SyntaxError)가 발생한다.
<br>

**◾️ 재할당 금지**
**`const`키워드로 선언한 변수는 재할당이 금지된다.** 재할당하는 경우 에러(TypeError)가 발생한다.
<br>

**◾️ 상수**
**상수는 재할당이 금지된 변수**를 말한다. 상수는 상태 유지와 가독성, 유지보수의 편의를 위해 <u>적극적인 사용이 권장</u>된다. 또한, <u>상수의 이름은 일반적으로 대문자로 선언</u>해 상수임을 명확히 나타내는데, 여러 단어로 이루어진 경우에는 언더스코어(\_)로 구분하는 '스네이크 케이스'로 표현하는 것이 일반적이다.

```
let preTaxPrice = 100;

// 상수 사용 없이 일반 숫자 값을 바로 연산에 사용 -> 어떤 의미로 사용했는지 직관적으로 알기 어려움
let afterTaxPrice = preTaxPrice + (preTaxPrice \* 0.1);

// 변수 이름을 세율을 의미하는+대문자로 선언하여 상수임을 명확히
const TAX_RATE = 0.1;
let afterTaxPrice = preTaxPrice + (preTaxPrice \* TAX_RATE);
```

<br>

**◾️ const 키워드와 객체**
`const`키워드로 선언된 변수에 원시 값을 할당하면 값을 변경할 수 없지만,
`const`키워드로 선언된 변수에 **객체를 할당하는 경우, 값을 변경할 수 있다.**
<span>&nbsp;&nbsp;&nbsp;&nbsp;🖍 원시 값은 재할당 없이 값을 변경할 수는 없으나, 객체는 재할당 없이도 직접 변경 가능하기 때문이다!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;따라서 **`const`키워드는 재할당이 금지될 뿐, "불변"을 의미하는 것이 아니다.**</span>
<br>

### 15.4 var vs. let vs. const

`var`, `let`, `const` 키워드 모두 각각의 특성을 고려하여 상황에 따라 적합한 키워드로 사용되어야 한다.

- ES6에서는 `var`키워드는 사용하지 않는다.
- 기본적으로 변수 선언에는 `const`키워드를 사용한다.
  - `let`키워드는 재할당이 필요한 경우에 한정하여 사용하는 것이 좋다.
  - 생각보다 재할당이 필요한 경우가 많지 않다. 그러니 일단은 `const`키워드 사용 ➡️ 추후 재할당이 필요하다면 `let`키워드로 변경
- 읽기 전용으로 사용하는 원시 값 & 객체에는 `const`키워드를 사용한다.

<br><br>

> **💬 이번 파트를 읽고 공부하면서...**
> 모던자바스크립트 딥 다이브 완독 도전 이전에 앞서 자바스크립트 강의로 자바스크립트를 한 차례 공부했다. 'ch.13 - 스코프'는 처음 강의로 공부할 때 헷갈렸던 개념 중 하나였다. 강의 예제를 보며 혼자 답을 예측할 때 반은 맞고 반은 틀릴 때가 많아 늘 헷갈렸다. 강의 상 스코프 진도가 끝났을 때에도 혼자 스코프 관련 구글링을 하고, 다른 예제들도 보면서 이해하려고 했다. 예제 보고 생각해볼 수록 조금씩 '오, 이래서 이렇게 되는건가' 싶었는데, 이번에 잘 정리된 개념책을 읽고, 이렇게 정리해보면서 안 보였던 부분도 보이고, 조금씩 퍼즐이 맞춰지는 느낌이 들었다. 개념도 중요하고, 이제 실습도 더 열심히 해야겠다.

```

```
