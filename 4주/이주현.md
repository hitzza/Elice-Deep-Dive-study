## 10-1 스코프

스코프는 식별자가 유효한 범위를 말한다. 즉 변수에 접근할 수 있는 범위를 말하는데 자바스크립트에는 두 가지 스코프가 존재한다.

1. 전역 스코프
2. 지역 스코프

전역 스코프는 말그대로 전역에 선언되어있어 어느 곳에서든 해당 변수에 접근할 수 있고, 지역 스코프는 함수 몸체 내부에 선언되어 지역 변수를 가지며 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

## 10-2 스코프 체인

스코프가 계층적으로 연결되어 있는 것을 스코프체인이라 한다.

변수를 참조할 때 스코프 체인을 통해 변수를 참조하는 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

- 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.

## 10-3 렉시컬 스코프

자바스크립트는 렉시컬 환경을 따르므로 함수를 어디서 호출했는지(동적 스코프)가 아니라 _**함수를 어디서 정의했는지**_(정적 스코프, 렉시컬 스코프)에 따라 상위 스코프를 결정한다.

**즉, 함수의 스코프는 언제나 자신이 정의된 스코프다.**

```
var x = 1; // global

function first() {
  var x = 10;
  second();
}

function second() {
  console.log(x);
}

first(); // ?
second(); // ?
```

여기서 왜 1이 2번 출력되는 것일까?

second() 함수가 first() 함수 안에서 호출된 것과 상관없이 second() 함수는 global 범위에 선언되어 있으므로, global 범위에 있는 변수 x의 값 1이 두 번 출력된 것이다.

## 11-1 변수의 생명 주기

### 지역 변수 생명 주기

지역 변수는 함수의 자신이 만들어진 함수의 생명 주기와 일치한다.
하지만 누군가 메모리 공간을 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.

### 전역 변수 생명 주기

var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.
( 전역 객체는 클라이언트 환경(브라우저)에서는 window, 서버 사이드 환경(node.js)에서는 global 객체를 의미한다)

## 11-2 전역 변수의 문제점

#### 1. 암묵적 결합

전역 변수는 어디에서나 참조하고 할당할 수 있는 변수를 사용하겠다는 것.
그래서 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용한다. 유효범위가 커 실수로 재할당하게 될수도 있고, 값을 변경하여도 오류를 찾기 어렵게 된다.

#### 2. 긴 생명 주기

생명 주기가 길기 때문에 메모리 리소스를 오랜 기간 소비한다.

#### 3. 스코프 체인 상에서 종점에 존재

스코프 체인 상에서 종점에 위치하므로, 변수를 검색할 때 가장 마지막에 검색된다. 즉, 전역 변수의 검색 속도가 가장 느리다.

#### 4. 네임스페이스 오염

파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다.
따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

## 11-3 전역 변수의 사용을 억제하는 방법

#### 1. 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

#### 2. 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 만들고 전역 변수처럼 사용하고 싶은 프로퍼티로 추가하는 방법.
(네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용하지 않다.)

#### 3. 모듈 패턴

클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.

#### 4. ES6 모듈

ES6 모듈을 파일 자체의 모듈 스코프를 제공한다.

```
<script type="module" src="app.mjs"></script>
```

## 12-1 var 키워드로 선언한 변수의 문제점

#### 1. 변수 중복 선언 허용

```
var x = 1;
var y = 1;

// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
// 초기화문이 없는 변수 선언문은 무시된다.

var x = 100;
var y;

console.log(x); // 100
console.log(y); // 1
```

만약 동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생한다.

#### 2. 함수 레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생한다.

#### 3. 변수 호이스팅

변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.
호이스팅에 의해 에러를 발생시키지는 않짐ㄴ 프로그램의 흐름상 맞지 않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.

## 12-2 let 키워드

#### 1. 변수 중복 선언 금지

let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러가 발생한다.

#### 2. 블록 레벨 스코프

let 키워드로 선언한 변수는 모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

#### 3. 변수 호이스팅

let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행된다.
let 키워드로 선언한 변수는 스코프의 시작지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없다. - 이러한 구간을 일시적 사각지대라고 부른다.

![](https://velog.velcdn.com/images/jutrong/post/de8653f2-13b9-4650-93af-3598006c2445/image.png)

#### 4. 전역 객체와 let

var 키워드와 달리 let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.
let 전역 변수는 보이지 않는 개념적인 블록 내에 존재한다.

## 12-3 const 키워드

#### 1. 선언과 초기화

const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.

```
const foo = 1;
```

그렇지 않으면 문법 에러가 발생한다.

블록 레벨 스코프를 가지며, 호이스팅이 발생하지 않는 것처럼 동작한다.

#### 2. 재할당 금지

var, let 키워드와 달리 재할당이 금지된다.

```
const foo = 1;
foo = 2; // TypeError
```

#### 3. 상수

const 키워드로 선언된 변수에 원시 값을 할당할 경우 원시 값은 변경할 수 없는 값이고 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.

```
const TAX_RATE = 0.1;

let preTaxPrice = 100;

let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);
```

나중에 세율이 변경되면 상수만 변경하면 되기 때문에 유지보수성이 대폭 향상된다.

#### 4. const 키워드와 객체

const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.
